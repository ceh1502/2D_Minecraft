import { useEffect, useState, useCallback, useRef } from 'react';
import { io } from 'socket.io-client';
import { InventoryModal, InventoryGrid, Hotbar, getCurrentToolType} from './components/InventoryUI'
import ShopModal from './components/ShopModal';
import './App.css';

// üîß ÏÉÅÎã®ÏúºÎ°ú ÎπºÎÇ∏ Í≥µÌÜµ Ìï®ÏàòÎì§

// ÏïÑÏù¥ÌÖú ÌÉÄÏûÖÎ≥Ñ Ïù¥Î™®ÏßÄ ÏïÑÏù¥ÏΩò Î∞òÌôò Ìó¨Ìçº Ìï®Ïàò
const getIconForItem = (type) => {
  switch (type) {
    case 'tree': return '/images/blocks/tree.png';
    case 'stone': return '/images/blocks/stone.png';
    case 'iron': return '/images/blocks/iron.png';
    case 'diamond': return '/images/blocks/dia.png';
    // ÎèÑÍµ¨ ÏïÑÏù¥ÏΩò Ï∂îÍ∞Ä
    case 'wooden_pickaxe': return '/images/items/wooden_pickaxe.png';
    case 'stone_pickaxe': return '/images/items/stone_pickaxe.png';
    case 'iron_pickaxe': return '/images/items/iron_pickaxe.png';
    case 'diamond_pickaxe': return '/images/items/diamond_pickaxe.png';

    case 'iron_sword': return '/images/items/iron_sword.png';
    case 'diamond_sword': return '/images/items/diamond_sword.png';

    case 'iron_axe': return '/images/items/iron_axe.png';
    case 'diamond_axe': return '/images/items/diamond_axe.png';

    // Î∞©Ïñ¥Íµ¨
    case 'iron_helmet': return '/images/items/iron_helmet.png';
    case 'iron_chest': return '/images/items/iron_chest.png';
    case 'iron_leggings': return '/images/items/iron_leggings.png';
    case 'iron_boots': return '/images/items/iron_boots.png';

    case 'diamond_helmet': return '/images/items/diamond_helmet.png';
    case 'diamond_chest': return '/images/items/diamond_chest.png';
    case 'diamond_leggings': return '/images/items/diamond_leggings.png';
    case 'diamond_boots': return '/images/items/diamond_boots.png';
    default: return '‚ùì';
  }
};

const getPlayerImage = (direction) => {
  switch (direction) {
    case 'up': return '/images/characters/avatar_up.png';
    case 'down': return '/images/characters/avatar_down.png';
    case 'left': return '/images/characters/avatar_left.png';
    case 'right': return '/images/characters/avatar_right.png';
    default: return '/images/characters/avatar_down.png';
  }
};

const PLACEABLE_BLOCKS = ['tree', 'stone', 'iron', 'diamond'];

// üîß Ïù∏Î≤§ÌÜ†Î¶¨ Î≥ÄÌôò Ìï®Ïàò (ÏÉÅÎã®ÏúºÎ°ú Ïù¥Îèô)
const convertInventoryToArray = (inventoryObj) => {
  const types = [
    'tree', 'stone', 'iron', 'diamond',
    'wooden_pickaxe', 'stone_pickaxe', 'iron_pickaxe', 'diamond_pickaxe',
    'iron_sword', 'diamond_sword',
    'iron_axe', 'diamond_axe',
    'iron_helmet', 'iron_chest', 'iron_leggings', 'iron_boots',
    'diamond_helmet', 'diamond_chest', 'diamond_leggings', 'diamond_boots'
  ];

  const flat = new Array(20).fill(null);
  let i = 0;
  types.forEach((type) => {
    const count = inventoryObj[type];
    if (count > 0 && i < 20) {
      flat[i++] = {
        name: type,
        count,
        icon: getIconForItem(type),
      };
    }
  });
  return flat;
};

function App() {
  const [socket, setSocket] = useState(null);
  const [connected, setConnected] = useState(false);
  const [isShopOpen, setIsShopOpen] = useState(false);
  
  // ‚úÖ ÎãâÎÑ§ÏûÑ ÏãúÏä§ÌÖú Ï∂îÍ∞Ä
  const [playerName, setPlayerName] = useState('');
  const [isNameSet, setIsNameSet] = useState(false);
  
  const [gameState, setGameState] = useState({
    mapData: null,
    players: [],
    currentPlayer: null,
    selectedSlot: 0,
    direction: 'down',
    inventory: new Array(20).fill(null), 
    isInventoryOpen: false
  });

  // üñ±Ô∏è ÎìúÎûòÍ∑∏ ÏÉÅÌÉú
  const [draggedItem, setDraggedItem] = useState(null);
  const [draggedFromIndex, setDraggedFromIndex] = useState(null);

  const gameStateRef = useRef(gameState);
  useEffect(() => {
    gameStateRef.current = gameState;
  }, [gameState]);

  // üñ±Ô∏è ÎìúÎûòÍ∑∏ Ìï∏Îì§Îü¨Îì§
  const handleDragStart = (e, item, index) => {
    setDraggedItem(item);
    setDraggedFromIndex(index);
    console.log(`üì¶ ÎìúÎûòÍ∑∏ ÏãúÏûë: ${item?.name} (Ïù∏Îç±Ïä§: ${index})`);
  };

  const handleDragOver = (e) => {
    e.preventDefault(); // ÎìúÎ°≠ ÌóàÏö©
  };

  const handleDrop = (e, targetIndex) => {
    e.preventDefault();
    
    if (draggedItem === null || draggedFromIndex === null) return;
    if (draggedFromIndex === targetIndex) {
      setDraggedItem(null);
      setDraggedFromIndex(null);
      return;
    }
    
    console.log(`üì¶ ÎìúÎ°≠: ${draggedItem.name} (${draggedFromIndex} ‚Üí ${targetIndex})`);
    
    // Ïù∏Î≤§ÌÜ†Î¶¨ ÏóÖÎç∞Ïù¥Ìä∏
    setGameState(prev => {
      const newInventory = [...prev.inventory];
      const targetItem = newInventory[targetIndex];
      
      // ÏïÑÏù¥ÌÖú ÏúÑÏπò ÍµêÌôò
      newInventory[draggedFromIndex] = targetItem;
      newInventory[targetIndex] = draggedItem;
      
      return {
        ...prev,
        inventory: newInventory
      };
    });
    
    setDraggedItem(null);
    setDraggedFromIndex(null);
  };

  const handleDragEnd = () => {
    setDraggedItem(null);
    setDraggedFromIndex(null);
  };
  
  // üî® ÏàòÏ†ïÎêú Ï±ÑÍµ¥ Ìï®Ïàò - ÎèÑÍµ¨ ÌÉÄÏûÖ Ï†ÑÏÜ°
  const tryMineBlock = useCallback(() => {
    if (!socket || !connected) return;

    const player = gameStateRef.current.currentPlayer;
    const mapData = gameStateRef.current.mapData;
    const direction = gameStateRef.current.direction;
    const inventory = gameStateRef.current.inventory;
    const selectedSlot = gameStateRef.current.selectedSlot;

    if (!player || !mapData) {
      return;
    }

    let targetX = player.position.x;
    let targetY = player.position.y;

    switch (direction) {
      case 'up': targetY -= 1; break;
      case 'down': targetY += 1; break;
      case 'left': targetX -= 1; break;
      case 'right': targetX += 1; break;
    }

    if (
      targetX < 0 || targetX >= mapData.width ||
      targetY < 0 || targetY >= mapData.height
    ) {
      return;
    }

    if (
      targetX === 0 || targetX === mapData.width - 1 ||
      targetY === 0 || targetY === mapData.height - 1
    ) {
      console.log('Îßµ ÌÖåÎëêÎ¶¨ ÌååÍ¥¥ X ');
      return;
    }

    // üî® ÌòÑÏû¨ Ïû•Ï∞©Îêú ÎèÑÍµ¨ ÌÉÄÏûÖ Í≥ÑÏÇ∞
    const currentToolType = getCurrentToolType(inventory, selectedSlot);
    
    console.log(`‚õèÔ∏è Ï±ÑÍµ¥ ÏãúÎèÑ: ÎèÑÍµ¨ÌÉÄÏûÖ=${currentToolType}, Ïä¨Î°Ø=${selectedSlot + 1}`);

    socket.emit('mine-block', { 
      x: targetX, 
      y: targetY,
      toolType: currentToolType  // ÎèÑÍµ¨ ÌÉÄÏûÖ Ï†ÑÏÜ°
    });
  }, [socket, connected]);

  // ÏúÑÏπò Í≥ÑÏÇ∞ Ìó¨Ìçº Ìï®Ïàò (ÏΩúÎ¶¨Ï†Ñ Ï≤¥ÌÅ¨ Ìè¨Ìï®)
  const calculateNewPosition = (currentPos, direction, mapData) => {
    const { x, y } = currentPos;
    
    let newX = x;
    let newY = y;
    
    switch (direction) {
      case 'up': newY = Math.max(1, y - 1); break;
      case 'down': newY = Math.min(48, y + 1); break;
      case 'left': newX = Math.max(1, x - 1); break;
      case 'right': newX = Math.min(48, x + 1); break;
      default: return currentPos;
    }
    
    // üöß Î∏îÎ°ù Ï∂©Îèå Ï≤¥ÌÅ¨
    if (mapData && mapData.cells) {
      const targetCell = mapData.cells[newY] && mapData.cells[newY][newX];
      if (targetCell) {
        // Í≥†Ï≤¥ Î∏îÎ°ùÎì§ (Ïù¥Îèô Î∂àÍ∞Ä)
        const solidBlocks = ['stone', 'tree', 'iron_ore', 'diamond'];
        
        if (solidBlocks.includes(targetCell.type)) {
          console.log(`üöß Ïù¥Îèô Ï∞®Îã®: ${targetCell.type} Î∏îÎ°ù`);
          return currentPos; // ÏõêÎûò ÏúÑÏπò Î∞òÌôò (Ïù¥Îèô Ï∑®ÏÜå)
        }
      }
    }
    
    return { x: newX, y: newY };
  };

  const tryPlaceBlock = useCallback(() => {
    if (!socket || !connected) return;

    const player = gameStateRef.current.currentPlayer;
    const mapData = gameStateRef.current.mapData;
    const direction = gameStateRef.current.direction;
    const selectedItem = gameStateRef.current.inventory[gameStateRef.current.selectedSlot];

    if (!selectedItem || !PLACEABLE_BLOCKS.includes(selectedItem.name)) {
      console.log('‚ùå ÏÑ§Ïπò Î∂àÍ∞Ä ÏïÑÏù¥ÌÖú:', selectedItem?.name);
      return;
    }

    let targetX = player.position.x;
    let targetY = player.position.y;

    switch (direction) {
      case 'up': targetY -= 1; break;
      case 'down': targetY += 1; break;
      case 'left': targetX -= 1; break;
      case 'right': targetX += 1; break;
    }

    const targetCell = mapData?.cells?.[targetY]?.[targetX];
    const belowCell = mapData?.cells?.[targetY + 1]?.[targetX];
    
    const solidBlocks = ['grass', 'stone', 'tree', 'iron_ore', 'diamond'];
    const isPlaceableSurface = belowCell && solidBlocks.includes(belowCell.type);

    if (targetCell?.type !== 'grass' || !isPlaceableSurface) {
      console.log('‚ùå ÏÑ§Ïπò Î∂àÍ∞ÄÌïú ÏúÑÏπò');
      return;
    }

    socket.emit('place-block', {
      x: targetX,
      y: targetY,
      blockType: selectedItem.name
    });
  }, [socket, connected]);

  // Í≤åÏûÑ Ï¥àÍ∏∞Ìôî
  useEffect(() => {
    if (!isNameSet) return;
    
    console.log('üéÆ Í≤åÏûÑ ÏãúÏûë!');
    
    const SERVER_URL = 'http://143.248.162.5:5001';
    console.log('üîó ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏãúÎèÑ:', SERVER_URL);

    const newSocket = io(SERVER_URL, {
      autoConnect: true,
      reconnection: true,
      reconnectionDelay: 1000,
      timeout: 10000,
      transports: ['polling', 'websocket'],
      forceNew: true
    });
    
    setSocket(newSocket);

    newSocket.on('connect', () => {
      console.log('‚úÖ ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏÑ±Í≥µ:', newSocket.id);
      setConnected(true);
      
      setTimeout(() => {
        console.log('üè† Î∞© ÏÉùÏÑ± ÏöîÏ≤≠: main_room');
        newSocket.emit('create-room', 'main_room');
        setTimeout(() => {
          const joinData = {
            roomId: 'main_room',
            username: playerName
          };
          console.log('üö™ Î∞© ÏûÖÏû• ÏöîÏ≤≠:', joinData);
          newSocket.emit('join-room', joinData);
        }, 100);
      }, 500);
    });

    newSocket.on('connect_error', (error) => {
      console.error('‚ùå ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïã§Ìå®:', error);
    });

    newSocket.on('disconnect', (reason) => {
      console.log('üîå Ïó∞Í≤∞ ÎÅäÍπÄ:', reason);
      setConnected(false);
    });

    // üéØ Î∞© ÏûÖÏû• ÏÑ±Í≥µ - ÎÇ¥ ÌîåÎ†àÏù¥Ïñ¥ Ï†ïÎ≥¥ ÌôïÏã§Ìûà ÏÑ§Ï†ï
    newSocket.on('player-joined', (data) => {
      console.log('üè† ÌîåÎ†àÏù¥Ïñ¥ ÏûÖÏû• Îç∞Ïù¥ÌÑ∞:', data);
      
      // ÎÇ¥ ÌîåÎ†àÏù¥Ïñ¥ Ï∞æÍ∏∞
      const myPlayer = data.room.players.find(p => p.playerId === newSocket.id);
      console.log('üë§ ÎÇ¥ ÌîåÎ†àÏù¥Ïñ¥ Ï†ïÎ≥¥:', myPlayer);
      
      setGameState(prev => ({
        ...prev,
        players: data.room.players,
        currentPlayer: myPlayer // ÌôïÏã§Ìûà ÎÇ¥ ÌîåÎ†àÏù¥Ïñ¥Îßå ÏÑ§Ï†ï
      }));
      
      newSocket.emit('request-map');
    });

    // üéØ Îßµ Îç∞Ïù¥ÌÑ∞ ÏàòÏã† - ÌîåÎ†àÏù¥Ïñ¥ Ï†ïÎ≥¥ Ïû¨ÌôïÏù∏
    newSocket.on('map-data', (data) => {
      console.log('üó∫Ô∏è Îßµ Îç∞Ïù¥ÌÑ∞ ÏàòÏã†:', data);
      
      setGameState(prev => {
        // ÎÇ¥ ÌîåÎ†àÏù¥Ïñ¥ Îã§Ïãú Ï∞æÍ∏∞ (ÌòπÏãú Î™®Î•º ÏÉÅÌô© ÎåÄÎπÑ)
        const myPlayer = data.allPlayers.find(p => p.playerId === newSocket.id);
        console.log('üó∫Ô∏è Îßµ Î°úÎî© Ïãú ÎÇ¥ ÌîåÎ†àÏù¥Ïñ¥:', myPlayer);
        
        return {
          ...prev,
          mapData: data.map,
          players: data.allPlayers,
          currentPlayer: myPlayer || prev.currentPlayer
        };
      });
    });

    // üéØ ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô - ÏôÑÏ†ÑÌûà ÏàòÏ†ïÎêú Î°úÏßÅ
    newSocket.on('player-moved', (data) => {
      console.log('üö∂ Ïù¥Îèô Ïù¥Î≤§Ìä∏ ÏàòÏã†:', {
        movedPlayerId: data.playerId,
        mySocketId: newSocket.id,
        isMyMovement: data.playerId === newSocket.id
      });
      
      setGameState(prev => {
        // üö® Ï§ëÏöî: ÎÇ¥ ÏõÄÏßÅÏûÑÏùÄ Î¨¥Ïãú (Î°úÏª¨ÏóêÏÑú Ïù¥ÎØ∏ Ï≤òÎ¶¨Îê®)
        if (data.playerId === newSocket.id) {
          console.log('‚è≠Ô∏è ÎÇ¥ ÏõÄÏßÅÏûÑ Ïù¥Î≤§Ìä∏ Î¨¥Ïãú');
          return prev;
        }
        
        // Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥Îì§Ïùò ÏõÄÏßÅÏûÑÎßå Ï≤òÎ¶¨
        const updatedPlayers = prev.players.map(p => 
          p.playerId === data.playerId
            ? { 
                ...p, 
                position: data.position,
                username: data.username || p.username
              }
            : p
        );

        console.log('üîÑ Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏:', data.playerId);

        return {
          ...prev,
          players: updatedPlayers
          // currentPlayerÎäî Ï†àÎåÄ Î≥ÄÍ≤ΩÌïòÏßÄ ÏïäÏùå!
        };
      });
    });

    // ÏÉàÎ°úÏö¥ Î∏îÎ°ù ÏóÖÎç∞Ïù¥Ìä∏ Ïù¥Î≤§Ìä∏
    newSocket.on('block-updated', ({ x, y, block, playerId, newInventory }) => {
      setGameState(prev => {
        if (!prev.mapData) return prev;

        const newCells = prev.mapData.cells.map(row => [...row]);
        if (newCells[y] && newCells[y][x]) {
          newCells[y][x] = block;
        }

        // üéØ ÎÇ¥Í∞Ä Ï±ÑÍµ¥Ìïú Í≤ΩÏö∞Îßå Ïù∏Î≤§ÌÜ†Î¶¨ ÏóÖÎç∞Ïù¥Ìä∏
        const shouldUpdateInventory = playerId === newSocket.id;

        return {
          ...prev,
          mapData: { ...prev.mapData, cells: newCells },
          currentPlayer: shouldUpdateInventory && prev.currentPlayer
            ? { ...prev.currentPlayer, inventory: newInventory }
            : prev.currentPlayer,
          inventory: shouldUpdateInventory
            ? convertInventoryToArray(newInventory)
            : prev.inventory
        };
      });
    });

    newSocket.on('mining-error', (data) => {
      console.log('‚ùå Ï±ÑÍµ¥ ÏóêÎü¨:', data.message);
    });

    newSocket.on('room-error', (data) => {
      console.error('üè† Î∞© ÏóêÎü¨:', data.message);
    });

    return () => {
      console.log('üîå ÏÜåÏºì Ïó∞Í≤∞ Ï¢ÖÎ£å');
      newSocket.close();
    };
  }, [isNameSet, playerName]);

  // Í±∞Îûò Í¥ÄÎ†® Ïù¥Î≤§Ìä∏ ÏàòÏã†
  useEffect(() => {
    if (!socket) return;

    const handleTradeSuccess = (data) => {
      console.log('‚úÖ Í±∞Îûò ÏÑ±Í≥µ:', data);
      console.log('üß™ ÏÑúÎ≤ÑÍ∞Ä Ï§Ä Ïù∏Î≤§ÌÜ†Î¶¨:', data.newInventory);

      // Ïòà: Î∞õÏùÄ ÏïÑÏù¥ÌÖú Ïù∏Î≤§ÌÜ†Î¶¨Ïóê Î∞òÏòÅ
      setGameState((prev) => ({
        ...prev,
        inventory: convertInventoryToArray(data.newInventory),
        currentPlayer: {
          ...prev.currentPlayer,
          inventory: data.newInventory
        }
      }));
    };

    const handleTradeError = (data) => {
      console.log('‚ùå Í±∞Îûò Ïã§Ìå®:', data.message);
      // ÎÇòÏ§ëÏóê UIÎ°ú ÏóêÎü¨ ÌÜ†Ïä§Ìä∏ ÎùÑÏö∏ ÏàòÎèÑ ÏûàÏñ¥
    };

    socket.on('trade-success', handleTradeSuccess);
    socket.on('trade-error', handleTradeError);

    return () => {
      socket.off('trade-success', handleTradeSuccess);
      socket.off('trade-error', handleTradeError);
    };
  }, [socket]);

  // üéØ ÌÇ§Î≥¥Îìú Ïª®Ìä∏Î°§ - Î°úÏª¨ Ïö∞ÏÑ† Ï≤òÎ¶¨
  useEffect(() => {
    const pressedKeys = new Set();

    const handleKeyDown = (e) => {
      if (draggedItem !== null) return;
      if (!socket || !connected) return;
      if (pressedKeys.has(e.key.toLowerCase())) return;
      
      const key = e.key.toLowerCase();
      pressedKeys.add(key);

      const moveMap = {
        w: 'up',
        a: 'left', 
        s: 'down',
        d: 'right',
      };

      if (moveMap[key]) {
        // üéØ Î°úÏª¨ ÏÉÅÌÉú Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏ (Î∂ÄÎìúÎü¨Ïö¥ ÏõÄÏßÅÏûÑ)
        setGameState(prev => {
          if (!prev.currentPlayer || !prev.mapData) return prev;
          
          const newDirection = moveMap[key];
          const newPosition = calculateNewPosition(prev.currentPlayer.position, newDirection, prev.mapData);
          
          // Ïù¥Îèô Î∂àÍ∞ÄÎä•Ìïú Í≤ΩÏö∞
          if (newPosition.x === prev.currentPlayer.position.x && 
              newPosition.y === prev.currentPlayer.position.y) {
            console.log('üöß Î°úÏª¨ Ïù¥Îèô Ï∞®Îã® - Î∞©Ìñ•Îßå Î≥ÄÍ≤Ω');
            return {
              ...prev,
              direction: newDirection
            };
          }
          
          // Ïù¥Îèô Í∞ÄÎä•Ìïú Í≤ΩÏö∞ - Î°úÏª¨ÏóêÏÑú Ï¶âÏãú Î∞òÏòÅ
          console.log(`üèÉ Î°úÏª¨ Ï¶âÏãú Ïù¥Îèô: ${prev.currentPlayer.username} ‚Üí (${newPosition.x}, ${newPosition.y})`);
          return {
            ...prev,
            direction: newDirection,
            currentPlayer: {
              ...prev.currentPlayer,
              position: newPosition
            }
          };
        });
        
        // üéØ ÏÑúÎ≤ÑÏóê ÏïåÎ¶º (Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥Îì§ÏùÑ ÏúÑÌï¥)
        socket.emit('move-player', moveMap[key]);
      }

      // Ïù∏Î≤§ÌÜ†Î¶¨ Ïä¨Î°Ø ÏÑ†ÌÉù 1~5
      const slotKeys = ['1', '2', '3', '4', '5'];
      const slotIndex = slotKeys.indexOf(e.key);
      if (slotIndex !== -1) {
        setGameState(prev => ({ ...prev, selectedSlot: slotIndex }));
        socket.emit('change-hotbar-slot', slotIndex);
      }

      // Ïù∏Î≤§ÌÜ†Î¶¨ Ïó¥Í∏∞/Îã´Í∏∞ (EÌÇ§)
      if (key === 'e') {
        setGameState(prev => ({
          ...prev,
          isInventoryOpen: !prev.isInventoryOpen
        }));
      }

      // JÌÇ§ ÎàÑÎ•¥Î©¥ Ïïû Î∏îÎ°ù Ï±ÑÍµ¥ ÏãúÎèÑ
      if (key === 'j') {
        tryMineBlock();
      }

      if (key === 'k') {
        tryPlaceBlock();
      }
    };

    const handleKeyUp = (e) => {
      pressedKeys.delete(e.key.toLowerCase());
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [socket, connected, tryMineBlock, draggedItem]);

  // ‚úÖ ÎãâÎÑ§ÏûÑ ÏûÖÎ†• ÌôîÎ©¥ (Í∞ÄÏû• Î®ºÏ†Ä Ï≤¥ÌÅ¨)
  if (!isNameSet) {
    return (
      <div className="name-input-screen">
        <div className="name-input-container">
          <h1>üéÆ ÎßàÏù∏ÌÅ¨ÎûòÌîÑÌä∏</h1>
          <h2>ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî</h2>
          <input
            type="text"
            placeholder="ÎãâÎÑ§ÏûÑ ÏûÖÎ†•..."
            value={playerName}
            onChange={(e) => setPlayerName(e.target.value)}
            onKeyPress={(e) => {
              if (e.key === 'Enter' && playerName.trim()) {
                setIsNameSet(true);
              }
            }}
            maxLength={12}
            autoFocus
          />
          <button 
            onClick={() => {
              if (playerName.trim()) setIsNameSet(true);
            }}
            disabled={!playerName.trim()}
          >
            Í≤åÏûÑ ÏãúÏûë
          </button>
        </div>
      </div>
    );
  }

  if (!connected) {
    return (
      <div className="loading-screen">
        <h1>üéÆ ÎßàÏù∏ÌÅ¨ÎûòÌîÑÌä∏ Í≤åÏûÑ</h1>
        <p>ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞ Ï§ë...</p>
      </div>
    );
  }

  if (!gameState.mapData) {
    return (
      <div className="loading-screen">
        <h1>üéÆ ÎßàÏù∏ÌÅ¨ÎûòÌîÑÌä∏ Í≤åÏûÑ</h1>
        <p>Îßµ Î°úÎî© Ï§ë...</p>
      </div>
    );
  }

  return (
    <div
      className="game-container"
      id="game-root"
      tabIndex={0}
      style={{ outline: 'none' }}
    >
      <div className="game-view">
        <GameMap 
          mapData={gameState.mapData}
          players={gameState.players}
          currentPlayer={gameState.currentPlayer}
          direction={gameState.direction}
        />
      </div>

      <div className="inventory-bar">
        <Hotbar 
          selectedSlot={gameState.selectedSlot}
          inventory={gameState.inventory}
          onDragStart={handleDragStart}
          onDrop={handleDrop}
          onDragOver={handleDragOver}
          onDragEnd={handleDragEnd}
        />
      </div>

      {gameState.isInventoryOpen && (
        <InventoryModal
          inventory={gameState.inventory}
          onClose={() =>
            setGameState(prev => ({ ...prev, isInventoryOpen: false }))
          }
          onDragStart={handleDragStart}
          onDrop={handleDrop}
          onDragOver={handleDragOver}
          onDragEnd={handleDragEnd}
        />
      )}

      {isShopOpen && (
        <ShopModal
          inventory={gameState.inventory}
          onClose={() => setIsShopOpen(false)}
          onBuy={(itemName) => {
            if (socket) socket.emit('trade-item', { itemName });
          }}
          onDragStart={handleDragStart}
          onDrop={handleDrop}
          onDragOver={handleDragOver}
          onDragEnd={handleDragEnd}
        />
      )}

      <div className="controls-guide">
        <p>üéÆ Ïù¥Îèô: WASD | Ïù∏Î≤§ÌÜ†Î¶¨: 1-5 | Ï±ÑÍµ¥: J</p>
      </div>

      <button className="shop-button" onClick={() => setIsShopOpen(true)}>
        <img src="/images/blocks/craft.png" alt="ÏÉÅÏ†ê" style={{ width: 48, height: 48 }} />
      </button>
    </div>
  );
}

function GameMap({ mapData, players, currentPlayer, direction }) {
  const [zoomLevel, setZoomLevel] = useState(2.5);
  
  if (!mapData || !currentPlayer) return null;

  const tileSize = 20;
  const gap = 0;
  const cellSize = tileSize + gap;

  const mapWidth = mapData.width * cellSize;
  const mapHeight = mapData.height * cellSize;

  // ÌôîÎ©¥ Ï§ëÏïô Í≥ÑÏÇ∞
  const screenCenterX = window.innerWidth / 2;
  const screenCenterY = window.innerHeight / 2;

  // ÌîåÎ†àÏù¥Ïñ¥ ÏõîÎìú Ï¢åÌëú
  const playerWorldX = currentPlayer.position.x * cellSize + cellSize / 2;
  const playerWorldY = currentPlayer.position.y * cellSize + cellSize / 2;

  // Ïπ¥Î©îÎùº Ïò§ÌîÑÏÖã (ÌîåÎ†àÏù¥Ïñ¥Î•º ÌôîÎ©¥ Ï§ëÏïôÏóê)
  const offsetX = screenCenterX - playerWorldX * zoomLevel;
  const offsetY = screenCenterY - playerWorldY * zoomLevel;

  return (
    <div className="game-map-wrapper">
      <div
        className="game-map"
        style={{
          width: mapWidth,
          height: mapHeight,
          transform: `translate(${offsetX}px, ${offsetY}px) scale(${zoomLevel})`,
          transformOrigin: '0 0'
        }}
      >
        {mapData.cells.map((row, y) =>
          row.map((cell, x) => (
            <div 
              key={`${x}-${y}`}
              className={`map-cell ${cell.type}`}
              style={{
                left: x * cellSize,
                top: y * cellSize,
                width: tileSize,
                height: tileSize
              }}
            >
              <img 
                src={getCellIcon(cell.type)}
                alt={cell.type} 
                width={tileSize}
                height={tileSize}
                style={{
                  clipPath: cell.type !== 'grass' ? `inset(0 0 ${cell.miningProgress || 0}% 0)` : 'none'
                }}
              />
            </div>
          ))
        )}

        {/* üéØ ÌòÑÏû¨ ÌîåÎ†àÏù¥Ïñ¥ (ÎÇ¥ Ï∫êÎ¶≠ÌÑ∞) */}
        <div
          className="player-container"
          style={{
            left: currentPlayer.position.x * cellSize,
            top: currentPlayer.position.y * cellSize,
            width: tileSize,
            height: tileSize,
            position: 'absolute'
          }}
        >
          {/* ÎãâÎÑ§ÏûÑ ÌëúÏãú */}
          <div className="player-nametag" style={{
            position: 'absolute',
            top: -20,
            left: '50%',
            transform: 'translateX(-50%)',
            background: 'rgba(0,200,0,0.8)', // ÎÇ¥ Ï∫êÎ¶≠ÌÑ∞Îäî Ï¥àÎ°ùÏÉâ
            color: 'white',
            padding: '2px 6px',
            borderRadius: '4px',
            fontSize: '10px',
            whiteSpace: 'nowrap',
            zIndex: 10
          }}>
            {currentPlayer.username} (ÎÇò)
          </div>
          
          {/* ÌîåÎ†àÏù¥Ïñ¥ Ïù¥ÎØ∏ÏßÄ */}
          <img
            src={getPlayerImage(direction)}
            alt="player"
            width={tileSize}
            height={tileSize}
            style={{
              border: '2px solid lime' // ÎÇ¥ Ï∫êÎ¶≠ÌÑ∞ ÌÖåÎëêÎ¶¨
            }}
          />
        </div>

        {/* üéØ Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥Îì§ */}
        {players
          .filter(p => p.playerId !== currentPlayer.playerId)
          .map(p => (
            <div
              key={p.playerId}
              className="player-container"
              style={{
                left: p.position.x * cellSize,
                top: p.position.y * cellSize,
                width: tileSize,
                height: tileSize,
                position: 'absolute'
              }}
            >
              {/* Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥ ÎãâÎÑ§ÏûÑ */}
              <div className="player-nametag" style={{
                position: 'absolute',
                top: -20,
                left: '50%',
                transform: 'translateX(-50%)',
                background: p.color || 'rgba(100,100,100,0.7)',
                color: 'white',
                padding: '2px 6px',
                borderRadius: '4px',
                fontSize: '10px',
                whiteSpace: 'nowrap',
                zIndex: 10
              }}>
                {p.username}
              </div>
              
              <img
                src={getPlayerImage('down')}
                alt="other player"
                width={tileSize}
                height={tileSize}
                style={{
                  border: '2px solid orange' // Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥ ÌÖåÎëêÎ¶¨
                }}
              />
            </div>
          ))
        }
      </div>
    </div>
  );
}

function getCellIcon(type) {
  const validTypes = ['grass', 'tree', 'stone', 'iron_ore', 'diamond'];
  if (validTypes.includes(type)) {
    return `/images/blocks/${type}.png`;
  }
  return '';
}

export default App;